.. Introduction to ATAC Analysis with DBiT-seq documentation master file, created by
   sphinx-quickstart on Tue Oct 25 22:49:32 2022.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Introduction to ATAC Analysis with DBiT-seq
=======================================================================

.. toctree::
   :maxdepth: 3
   :caption: Contents:

Description
-----------
The aim of this tutorial is to provide a brief introduction to getting started with basic downstream spatial ATAC analysis
prepared by the Deterministic Barcoding in Tissue for Spatial Omics Sequencing (DBiT-seq) protocol. Much of
this tutorial centers around the usage of both `ArchR  <https://www.archrproject.com/bookdown/index.html>`_
and `Seurat <https://satijalab.org/seurat>`_ to create a spatially resolved ATAC object from which we can map ATAC gene scores 
back to the tissue histology. Each step in this analysis workflow closely follows standard scATAC downstream analysis 
as outlined in ArchR's tutorial.


Dependencies
------------


Quick Start
-----------

Load needed libraries: ::

   library(ArchR)
   library(Seurat)
   library(grid)
   library(knitr)
   library(patchwork)
   library(gridExtra)
   library(kableExtra)
   library(dplyr)
   library(tibble)
   library(hdf5r)
   library(clusterProfiler)
   library(org.Mm.eg.db)
   library(org.Hs.eg.db)
   library(org.Rn.eg.db)
   library(repr)
   library(stringr)
   library(magick)
   library(rjson)
   library(SeuratDisk)
   library(rmarkdown)
   library(purrr)
   


Before starting downstream analysis in ArchR, a few global parameters must be set: ::

   data_species <- 'mm10'
   num_threads <- '2'
   tile_size <- 5000
   addArchRGenome(data_species)
   geneAnnotation <- getGeneAnnotation()
   genomeAnnotation <- getGenomeAnnotation()
   genomeSize = 3.0e+09
   set.seed(1234)
   addArchRThreads(threads = num_threads)


Once generating the needed fragments.tsv file outputted from Cellranger for a specific sample, we can now create
an ArchR **ArrowFile** which will form the basis of our ATAC analysis. During the ArrowFile creation step, all of the
necessary data and metadata for the given sample will be generated and stored on disk in HD5 format. A few parameters such as 
minTSS and minFrags, which respectively denote the lowest TSS enrichment score and lowest number of fragments can
be passed to filter out any bad quality tixels from the dataset. Here, an ArrowFile for a single fragments.tsv associated with an 
arbitrary 'Control' sample is created::

   inputFile <- "/path/to/fragments.tsv.gz"
   project_name <- 'Control'
   ArrowFiles <- createArrowFiles(
      inputFiles = inputFile,
      sampleNames = project_name,
      geneAnnotation = geneAnnotation,
      genomeAnnotation = genomeAnnotation,
      minTSS = min_TSS,
      minFrags = min_Frags,
      maxFrags = 1e+07,
      addTileMat = TRUE,
      addGeneScoreMat = TRUE,
      offsetPlus = 0,
      offsetMinus = 0,
      force = TRUE,
      TileMatParams = list(tileSize = tile_size)
   )

ArchR can then access this data through associating the newly created ArrowFiles with an **ArchRProject**. An ArchRProject is 
a data structure stored in memory that can be easily accessed/mutated by R. Every operation on the ArchRProject affects its associated
ArrowFile. All of the archR downstream analysis will take place on the ArchRProject. To create an ArchRProject, pass in the previously
created ArrowFiles object to the ArchRProject function call::
   proj <- ArchRProject(
      ArrowFiles = ArrowFiles, 
      outputDirectory = project_name,
      geneAnnotation = geneAnnotation,
      genomeAnnotation = genomeAnnotation,
      copyArrows = TRUE
   )

Once the ArchRProject is created, the spatial information contained in the folder generated by AtlasXBrowser can now be integrated. To
do so, we leverage Seurat's spatial transcriptomic capabilities to incorporate the gene-score matrix computed in the createArrowFiles step 
with the spatial histology using a predefined **Load_AtlasXomicsEpi** function. Here, Load_AtlasXomicsEpi takes in the following parameters:

   * **proj**: ArchRProject object
   * **meta.data**: Dataframe object containing getCellColData(proj) content
   * **filter.matrix**: Boolean indicating whether to filter all off tissue tixels
   * **threshold**: Double indicating the Log2FC lowerbound for differentially expressed markers
   * **spatialFolder**: A path to the spatial folder generated by AtlasXBrowser
   * **lsi_res**: Resolution passed to clusterParams in addIterativeLSI call
   * **res**: Resolution passed to addClusters call
   * **fdr**: Double indicating the false discover rate for differentially expressed markers

Within this function, spatial information is added to a Read10X_image object, dimensionality reduction is 
computed via IterativeLSI technique, and clustering is performed using the standard Seurat v3 community neighborhood 
detection method via **addClusters(â€¦)**. Clusters are then embedded into a UMAP space purely for visualization purposes.
Marker features for genescores are computed using the default t-test on cluster identities. These marker features
will serve as the only features to be included in the genescore matrix when exported to Seurat's counts slot. Finally, the 
'subsetted' gene-score matrix along with the 10X Visium image object are then combined together to create a spatially resolved
ATAC object containing all of the spatial information and metadata computed in ArchR. ::

   ############### Prepare meta.data
   meta.data <- as.data.frame(getCellColData(ArchRProj = proj))
   meta.data['cellID_archr'] <- row.names(meta.data)
   new_row_names <- row.names(meta.data)
   new_row_names <- unlist(lapply(new_row_names, function(x) gsub(".*#","", x)))
   new_row_names <- unlist(lapply(new_row_names, function(x) gsub("-.*","", x)))
   row.names(meta.data) <- new_row_names

   ############### Function for constructing objects
   Load_AtlasXomicsEpi <- function(
      proj,
      meta.data,
      spatialFolder,
      filter.matrix = TRUE,
      threshold,
      lsi_res = .2,
      res = .5,
      fdr = .05
      ) {
         image = Read10X_Image(image.dir = spatialFolder, filter.matrix = filter.matrix)
         sequenced_tixels <- row.names(meta.data)
         image <- image[sequenced_tixels, ]
         meta.data.spatial <- meta.data[row.names(image@coordinates), ]
         proj_in_tissue <- proj[meta.data.spatial$cellID_archr, ]
         
         proj_in_tissue <- addIterativeLSI(
            ArchRProj = proj_in_tissue,
            useMatrix = "TileMatrix", 
            name = "IterativeLSI", 
            iterations = 2, 
            clusterParams = list(
            resolution = c(lsi_res), 
            sampleCells = 10000, 
            n.start = 10
            ), 
            varFeatures = 25000, 
            dimsToUse = 1:30,
            force = TRUE
         )
         
         proj_in_tissue <- addClusters(
            input = proj_in_tissue,
            reducedDims = "IterativeLSI",
            method = "Seurat",
            name = "Clusters",
            resolution = res,
            force = TRUE
         )
         
         proj_in_tissue <- addUMAP(
            ArchRProj = proj_in_tissue, 
            reducedDims = "IterativeLSI", 
            name = "UMAP", 
            nNeighbors = 30, 
            minDist = 0.5, 
            metric = "cosine",
            force = TRUE
         )
         
         proj_in_tissue <- addImputeWeights(proj_in_tissue)
         status = 0
         marker_vec <- tryCatch(expr = {
            markersGS <- getMarkerFeatures(
            ArchRProj = proj_in_tissue,
            useMatrix = "GeneScoreMatrix",
            groupBy = "Clusters",
            testMethod = "ttest"
            )
            # For some runs, "FDR < 0.05" won't work
            if ( threshold > 0 ) {
               markerList <- getMarkers(markersGS, cutOff = "FDR <= fdr & Log2FC >= threshold")
               for(i in names(markerList)){
                  markerList[[i]] <- markerList[[i]][order(markerList[[i]]$Log2FC, decreasing = TRUE),]
               }
            } else {
               markerList <- getMarkers(markersGS, cutOff = "FDR <= fdr & Log2FC <= threshold")
               for(i in names(markerList)){
                  markerList[[i]] <- markerList[[i]][order(markerList[[i]]$Log2FC, decreasing = FALSE),]
               }
            }
            
            markerGenes <- list()
            for (i in seq_len(length(markerList))) {
            markerGenes <- c(markerGenes, markerList[[i]]$name)
            }
            
            
            if (length(markerGenes) == 0){
            print("Marker genes vec is empty")
            markerList <- c('')
            status = 1
            } else {
            markerGenes <- unique(unlist(markerGenes))
            }
            marker_vec <- list(markerGenes = markerGenes, markerList = markerList, status = status)
         }, error = function(e){
            print(paste0("markerGenes cannot be created. Original error: ", e))
            markerGenes = c('')
            markerList = c('')
            status = 1
            marker_vec <- list(markerGenes = markerGenes, markerList = markerList, status = status)
            return(marker_vec)
         })
         
         markerGenes <- marker_vec[["markerGenes"]]
         print(paste0("markerGenes: ", markerGenes))
         markerList <- marker_vec[["markerList"]]
         #print(paste0("markerList: ", markerList))
         status <- marker_vec[["status"]]
         print(paste0("status: ", status))
         
         proj_in_tissue <- addImputeWeights(proj_in_tissue)
         gene_score <- getGeneScore_ArchR(ArchRProj = proj_in_tissue, name = markerGenes, imputeWeights = getImputeWeights(proj_in_tissue))
         object <- CreateSeuratObject(counts = gene_score, assay = "Spatial", meta.data = meta.data)

         print(object)
         image <- image[Cells(x = object)]
         DefaultAssay(object = image) <- "Spatial"
         object[["slice1"]] <- image
         spatial.obj <- object
         objList <- list("proj_in_tissue" = proj_in_tissue, "spatial.obj" = spatial.obj, 'markerList' = markerList, 'status' = status)
         #print(paste0("out_vec: ", out_vec))
         return(objList)
      }

      objList <- Load_AtlasXomicsEpi(proj, meta.data, spatialFolder, filter.matrix = TRUE, threshold)
      proj_in_tissue <- objList$proj_in_tissue
      spatial_in_tissue.obj <- objList$spatial.obj
      markerList <- objList$markerList

      spatial_in_tissue.obj$orig.ident = as.factor(project_name)
      Idents(spatial_in_tissue.obj) = 'orig.ident'
      spatial_in_tissue.obj = AddMetaData(spatial_in_tissue.obj, spatial_in_tissue.obj@images$slice1@coordinates)

Once the spatial objects have been generated, various metadata and genescore information can now be plotted
back to spatial images using standard Seurat functions :: 

   spatial_in_tissue.obj@meta.data$Clusters = proj_in_tissue$Clusters
   plot_spatial = SpatialDimPlot(
   spatial_in_tissue.obj,
   group.by = "Clusters",
   label = FALSE, label.size = 3,
   pt.size.factor = pt_size_factor, cols = cols, stroke = 0) + 
   theme(
      plot.title = element_blank(),
      legend.position = "right",
      text=element_text(size=21)) +
   ggtitle(project_name) + theme(plot.title = element_text(hjust = 0.5), text=element_text(size=21)) 

   plot_spatial$layers[[1]]$aes_params <-
   c(plot_spatial$layers[[1]]$aes_params, shape=22)

   plot_spatial

Standard ArchR plotting can be used with the computed **proj_in_tissue** project. For more information on
function methodology and documentation, please see ArchR's `tutorial  <https://www.archrproject.com/bookdown/index.html>`_

Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
